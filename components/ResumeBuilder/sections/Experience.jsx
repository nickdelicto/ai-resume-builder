import React, { useState, useEffect, useRef } from 'react';
import styles from './Sections.module.css';
import { toast } from 'react-hot-toast';

const Experience = ({ data, updateData, jobContext }) => {
  // Ensure data is always an array with at least one default item
  const [experiences, setExperiences] = useState(() => {
    const defaultExperience = { 
    title: '', 
    company: '', 
    location: '', 
    startDate: '', 
    endDate: '', 
    description: '' 
    };
    
    if (!data || !Array.isArray(data) || data.length === 0) {
      return [defaultExperience];
    }
    
    // Normalize each experience to ensure it has all required properties
    return data.map(exp => ({
      title: exp.title || '',
      company: exp.company || '',
      location: exp.location || '',
      startDate: exp.startDate || '',
      endDate: exp.endDate || '',
      description: exp.description || ''
    }));
  });
  
  const [currentIndex, setCurrentIndex] = useState(0);
  const [isGenerating, setIsGenerating] = useState(false);
  const [autoGeneratedIndices, setAutoGeneratedIndices] = useState(new Set());
  const [showRequiredFieldsWarning, setShowRequiredFieldsWarning] = useState(false);
  const autoGenerationTimeoutRef = useRef(null);
  const formContentRef = useRef(null);
  const [showBulletPreview, setShowBulletPreview] = useState(false);
  
  // Scroll to form content when changing experiences
  useEffect(() => {
    if (formContentRef.current) {
      // Scroll the form container into view when changing experiences
      formContentRef.current.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
  }, [currentIndex]);
  
  useEffect(() => {
    if (data && Array.isArray(data) && data.length > 0) {
      // Normalize the data to ensure all required fields exist
      const normalizedData = data.map(exp => ({
        title: exp.title || '',
        company: exp.company || '',
        location: exp.location || '',
        startDate: exp.startDate || '',
        endDate: exp.endDate || '',
        description: exp.description || ''
      }));
      
      setExperiences(normalizedData);
      
      // Mark all imported experiences as already processed for auto-generation
      // This prevents auto-generation for experiences imported from resume
      const newAutoGeneratedIndices = new Set(autoGeneratedIndices);
      for (let i = 0; i < normalizedData.length; i++) {
        // If experience has substantial data, mark it as already processed
        if (normalizedData[i].title && normalizedData[i].company) {
          newAutoGeneratedIndices.add(i);
        }
      }
      setAutoGeneratedIndices(newAutoGeneratedIndices);
      
      // Ensure currentIndex is valid for the new data
      if (currentIndex >= normalizedData.length) {
        setCurrentIndex(Math.max(0, normalizedData.length - 1));
      }
    }
  }, [data]);
  
  // This effect handles auto-generation of descriptions when fields are filled
  useEffect(() => {
    const currentExp = experiences[currentIndex];
    
    // Check if title, company, startDate, and endDate are all filled and this experience hasn't been auto-generated yet
    if (currentExp?.title && 
        currentExp?.company && 
        currentExp?.startDate && 
        currentExp?.endDate && 
        !currentExp.description && 
        !autoGeneratedIndices.has(currentIndex) &&
        !isGenerating) {
      
      // Clear any existing timeout to avoid multiple generations
      if (autoGenerationTimeoutRef.current) {
        clearTimeout(autoGenerationTimeoutRef.current);
      }
      
      // Set a short delay before auto-generating to avoid generating content while user is still typing
      autoGenerationTimeoutRef.current = setTimeout(() => {
        // Only generate if the user hasn't manually added content already
        if (!currentExp.description) {
          autoGenerateDescription();
        }
      }, 800); // Delay of 800ms after fields are filled
    }
    
    return () => {
      if (autoGenerationTimeoutRef.current) {
        clearTimeout(autoGenerationTimeoutRef.current);
      }
    };
  }, [experiences, currentIndex]);
  
  const handleInputChange = (field, value) => {
    // Make sure experiences array and current index are valid
    if (!experiences || !Array.isArray(experiences) || currentIndex >= experiences.length) {
      console.error('Invalid experiences data structure in handleInputChange');
      return;
    }
    
    const updatedExperiences = [...experiences];
    updatedExperiences[currentIndex] = {
      ...updatedExperiences[currentIndex],
      [field]: value
    };
    
    setExperiences(updatedExperiences);
    updateData(updatedExperiences);
    
    // Clear warning when user enters data in required fields
    if ((field === 'title' || field === 'company') && showRequiredFieldsWarning) {
      const currentExp = updatedExperiences[currentIndex];
      if (currentExp.title && currentExp.company) {
        setShowRequiredFieldsWarning(false);
      }
    }
    
    // Only show bullet preview for description field if enough content is entered
    if (field === 'description') {
      // Check if there's enough content to show bullet preview (at least 400 characters)
      const hasSubstantialContent = value && value.trim().length >= 400;
      
      if (hasSubstantialContent) {
      setShowBulletPreview(true);
      } else if (value.trim().length > 0) {
        // If there's some content but not enough, don't change existing preview state
        // This prevents toggling the preview on and off during typing
      } else {
        // If no content, hide the preview
        setShowBulletPreview(false);
      }
    }
  };
  
  const handleFieldBlur = (field) => {
    // Make sure experiences array and current index are valid
    if (!experiences || !Array.isArray(experiences) || currentIndex >= experiences.length) {
      console.error('Invalid experiences data structure in handleFieldBlur');
      return;
    }
    
    // When the user leaves a required field, we check if we can auto-generate
    const currentExp = experiences[currentIndex];
    if (!currentExp) return;
    
    // Only check for auto-generation if it's one of the required fields
    if (field === 'title' || field === 'company' || field === 'startDate' || field === 'endDate') {
      // Only auto-generate if ALL required fields are filled and description is empty
      if (currentExp.title && 
          currentExp.company && 
          currentExp.startDate && 
          currentExp.endDate && 
          !currentExp.description && 
          !autoGeneratedIndices.has(currentIndex) &&
          !isGenerating) {
            
        // Set a short delay before auto-generating
        if (autoGenerationTimeoutRef.current) {
          clearTimeout(autoGenerationTimeoutRef.current);
        }
        
        autoGenerationTimeoutRef.current = setTimeout(() => {
          autoGenerateDescription();
        }, 800); // Short delay after blur to avoid interrupting user flow
      }
    }
  };
  
  const addNewExperience = () => {
    // Ensure experiences is an array before trying to update it
    if (!experiences || !Array.isArray(experiences)) {
      console.error('Invalid experiences data structure in addNewExperience');
      
      // Reset experiences to a default array with one item if it's invalid
      const defaultExperience = { 
        title: '', 
        company: '', 
        location: '', 
        startDate: '', 
        endDate: '', 
        description: '' 
      };
      
      setExperiences([defaultExperience]);
      setCurrentIndex(0);
      updateData([defaultExperience]);
      return;
    }
    
    const updatedExperiences = [
      ...experiences,
      { 
        title: '', 
        company: '', 
        location: '', 
        startDate: '', 
        endDate: '', 
        description: '' 
      }
    ];
    
    setExperiences(updatedExperiences);
    setCurrentIndex(updatedExperiences.length - 1);
    updateData(updatedExperiences);
    
    // Clear any warnings when creating a new experience
    setShowRequiredFieldsWarning(false);
  };
  
  const removeExperience = (index) => {
    // Ensure experiences is a valid array
    if (!experiences || !Array.isArray(experiences)) {
      console.error('Invalid experiences data structure in removeExperience');
      return;
    }
    
    // Make sure index is valid
    if (index < 0 || index >= experiences.length) {
      console.error(`Invalid index ${index} in removeExperience`);
      return;
    }
    
    // Don't remove if it's the only one
    if (experiences.length === 1) {
      return;
    }
    
    const updatedExperiences = experiences.filter((_, i) => i !== index);
    setExperiences(updatedExperiences);
    
    // Adjust current index if needed
    if (index <= currentIndex) {
      setCurrentIndex(Math.max(0, currentIndex - 1));
    }
    
    // Remove from auto-generated set if present
    if (autoGeneratedIndices.has(index)) {
      const updatedIndices = new Set(autoGeneratedIndices);
      updatedIndices.delete(index);
      
      // Adjust indices for experiences after the deleted one
      const adjustedIndices = new Set();
      updatedIndices.forEach(idx => {
        if (idx > index) {
          adjustedIndices.add(idx - 1);
        } else {
          adjustedIndices.add(idx);
        }
      });
      
      setAutoGeneratedIndices(adjustedIndices);
    }
    
    updateData(updatedExperiences);
    
    // Clear any warnings when removing an experience
    setShowRequiredFieldsWarning(false);
  };
  
  // Add a minimum character requirement constant
  const MIN_DESCRIPTION_LENGTH = 400;
  
  const autoGenerateDescription = async () => {
    // Make sure experiences array and current index are valid
    if (!experiences || !Array.isArray(experiences) || currentIndex >= experiences.length) {
      console.error('Invalid experiences data structure in autoGenerateDescription');
      return;
    }
    
    const currentExp = experiences[currentIndex];
    if (!currentExp) return;
    
    // This is the auto-triggered version of generateDescription that happens
    // when the user has filled out all required fields (title, company, startDate, endDate)
    if (!currentExp.title || 
        !currentExp.company || 
        !currentExp.startDate || 
        !currentExp.endDate) {
      return; // Don't generate if any required field is missing
    }
    
    setIsGenerating(true);
    
    // Determine if we're improving existing content or generating new content
    const isImproving = currentExp.description && currentExp.description.trim().length > 0;
    
    // Mark this experience as auto-generated to prevent future auto-generation
    // even if the user changes the fields later
    const updatedIndices = new Set(autoGeneratedIndices);
    updatedIndices.add(currentIndex);
    setAutoGeneratedIndices(updatedIndices);
    
    try {
      // Call our API endpoint with the appropriate action
      const response = await fetch('/api/generate-experience', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          title: currentExp.title,
          company: currentExp.company,
          location: currentExp.location,
          startDate: currentExp.startDate,
          endDate: currentExp.endDate,
          description: isImproving ? currentExp.description : null, // Include existing description for improvement
          jobContext: jobContext?.description || null,
          action: isImproving ? 'improve' : 'generate' // Specify action type
        }),
      });

      if (!response.ok) {
        // Check for specific error types
        const errorData = await response.json().catch(() => ({}));
        
        // Handle specific error codes
        if (response.status === 429) {
          throw new Error('Rate limit exceeded. Please try again later.');
        } else if (response.status === 403) {
          throw new Error('API key invalid or expired.');
        } else if (errorData.error) {
          throw new Error(errorData.error);
        } else {
          throw new Error('Failed to generate description');
        }
      }

      const data = await response.json();
      
      if (data.description) {
        handleInputChange('description', data.description);
        
        // Always show bullet preview after generation
        setShowBulletPreview(true);
        
        // Show success message for improvement only
        if (isImproving) {
          toast.success('Your experience description has been improved!', { duration: 3000 });
        }
      } else {
        throw new Error('No description generated');
      }
    } catch (error) {
      console.error('Error generating description:', error);
      
      // Create custom error messages based on error type
      let errorMessage = 'Oh boy! We\'re having trouble generating your job description.';
      
      // Check for common API errors
      if (error.message.includes('API key')) {
        errorMessage = 'Our AI service is temporarily unavailable.';
      } else if (error.message.includes('rate limit')) {
        errorMessage = 'We\'ve reached our AI service limit for the moment.';
      } else if (error.message.includes('timeout') || error.message.includes('network')) {
        errorMessage = 'Connection to our AI service timed out.';
      }
      
      toast.error(
        <div>
          <p>{errorMessage}</p>
          <p>Please try again or <a href="/contact" style={{ color: 'var(--primary-blue)', textDecoration: 'underline' }}>contact us</a> for assistance.</p>
        </div>,
        { duration: 7000 }
      );
    } finally {
      setIsGenerating(false);
    }
  };
  
  const generateDescription = async () => {
    // Make sure experiences array and current index are valid
    if (!experiences || !Array.isArray(experiences) || currentIndex >= experiences.length) {
      console.error('Invalid experiences data structure in generateDescription');
      return;
    }
    
    const currentExp = experiences[currentIndex];
    if (!currentExp) return;
    
    // This is the manually triggered version of generateDescription
    if (!currentExp.title || !currentExp.company) {
      // Replace alert with in-component warning
      setShowRequiredFieldsWarning(true);
      // Clear warning after 10 seconds
      setTimeout(() => setShowRequiredFieldsWarning(false), 10000);
      return;
    }
    
    // Determine if we're improving existing content or generating new content
    const isImproving = currentExp.description && currentExp.description.trim().length > 0;
    
    // Mark this experience as auto-generated to avoid re-generating
    // Even if manually triggered, we want to prevent future auto-generation
    const updatedIndices = new Set(autoGeneratedIndices);
    updatedIndices.add(currentIndex);
    setAutoGeneratedIndices(updatedIndices);
    
    setIsGenerating(true);
    
    try {
      // Call our API endpoint with the appropriate action
      const response = await fetch('/api/generate-experience', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          title: currentExp.title,
          company: currentExp.company,
          location: currentExp.location,
          startDate: currentExp.startDate,
          endDate: currentExp.endDate,
          description: isImproving ? currentExp.description : null, // Include existing description for improvement
          jobContext: jobContext?.description || null,
          action: isImproving ? 'improve' : 'generate' // Specify action type
        }),
      });

      if (!response.ok) {
        // Check for specific error types
        const errorData = await response.json().catch(() => ({}));
        
        // Handle specific error codes
        if (response.status === 429) {
          throw new Error('Rate limit exceeded. Please try again later.');
        } else if (response.status === 403) {
          throw new Error('API key invalid or expired.');
        } else if (errorData.error) {
          throw new Error(errorData.error);
        } else {
          throw new Error('Failed to generate description');
        }
      }

      const data = await response.json();
      
      if (data.description) {
        handleInputChange('description', data.description);
        
        // Always show bullet preview after generation
        setShowBulletPreview(true);
        
        // Show different success messages based on action
        const actionMessage = isImproving 
          ? 'Your experience description has been improved!' 
          : 'New experience description generated!';
        
        toast.success(actionMessage, { duration: 3000 });
      } else {
        throw new Error('No description generated');
      }
    } catch (error) {
      console.error('Error generating description:', error);
      
      // Create custom error messages based on error type
      let errorMessage = 'Oh boy! We\'re having trouble generating your job description.';
      
      // Check for common API errors
      if (error.message.includes('API key')) {
        errorMessage = 'Our AI service is temporarily unavailable.';
      } else if (error.message.includes('rate limit')) {
        errorMessage = 'We\'ve reached our AI service limit for the moment.';
      } else if (error.message.includes('timeout') || error.message.includes('network')) {
        errorMessage = 'Connection to our AI service timed out.';
      }
      
      toast.error(
        <div>
          <p>{errorMessage}</p>
          <p>Please try again or <a href="/contact" style={{ color: 'var(--primary-blue)', textDecoration: 'underline' }}>contact us</a> for assistance.</p>
        </div>,
        { duration: 7000 }
      );
    } finally {
      setIsGenerating(false);
    }
  };

  // Add this helper function to determine button text
  const getButtonText = () => {
    if (isGenerating) {
      return 'Generating...';
    }
    
    const currentExp = experiences[currentIndex];
    if (currentExp && currentExp.title && currentExp.company && currentExp.description) {
      return '✨ Improve Job Description';
    }
    
    return '✨ Generate Job Description';
  };

  // Helper function to format description text for the bullet preview
  const formatBulletPreview = (text) => {
    if (!text) return [];
    
    // Split by newlines and filter out empty lines
    return text.split('\n')
      .filter(line => line.trim() !== '')
      .map(line => {
        // Remove bullet characters if they already exist
        return line.replace(/^[•\-*]\s*/, '').trim();
      });
  };

  // Helper function to truncate text for tab display
  const truncateText = (text, maxLength = 25) => {
    if (!text) return '';
    return text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
  };

  return (
    <div className={styles.sectionContainer}>
      <h2 className={styles.sectionTitle}>Work Experience</h2>
      <p className={styles.sectionDescription}>
        Your work history is one of the most important parts of your resume. Focus on achievements rather than duties.
      </p>
      
      {/* Experience Tabs Navigation */}
      <div className={styles.experienceTabs}>
        {Array.isArray(experiences) && experiences.map((exp, index) => (
          <div 
            key={index}
            className={`${styles.experienceTab} ${index === currentIndex ? styles.activeTab : ''}`}
            onClick={() => setCurrentIndex(index)}
          >
            <span className={styles.tabContent}>
              {(exp?.title || exp?.company) 
                ? `${truncateText(exp?.title || 'Position')} at ${truncateText(exp?.company || 'Company')}` 
                : `Experience ${index + 1}`}
            </span>
            {Array.isArray(experiences) && experiences.length > 1 && (
              <button 
                className={styles.removeButton}
                onClick={(e) => {
                  e.stopPropagation();
                  removeExperience(index);
                }}
                aria-label="Remove experience"
              >
                ×
              </button>
            )}
          </div>
        ))}
        
        <button 
          className={styles.addButton}
          onClick={addNewExperience}
          aria-label="Add experience"
        >
          + Add Position
        </button>
      </div>
      
      {/* Experience Fields */}
      <div ref={formContentRef} id="experienceFormContent">
        <div className={styles.formGrid}>
          <div className={styles.formGroup}>
            <label htmlFor="title">Job Title</label>
            <input
              type="text"
              id="title"
              value={experiences[currentIndex]?.title || ''}
              onChange={(e) => handleInputChange('title', e.target.value)}
              onBlur={() => handleFieldBlur('title')}
              placeholder="e.g. Product Manager"
              className={styles.formInput}
            />
          </div>
          
          <div className={styles.formGroup}>
            <label htmlFor="company">Company</label>
            <input
              type="text"
              id="company"
              value={experiences[currentIndex]?.company || ''}
              onChange={(e) => handleInputChange('company', e.target.value)}
              onBlur={() => handleFieldBlur('company')}
              placeholder="e.g. ABC Corporation"
              className={styles.formInput}
            />
          </div>
          
          <div className={styles.formGroup}>
            <label htmlFor="location">Location</label>
            <input
              type="text"
              id="location"
              value={experiences[currentIndex]?.location || ''}
              onChange={(e) => handleInputChange('location', e.target.value)}
              placeholder="e.g. San Francisco, CA"
              className={styles.formInput}
            />
          </div>
          
          <div className={styles.formGroup}>
            <label htmlFor="startDate">Start Date</label>
            <input
              type="text"
              id="startDate"
              value={experiences[currentIndex]?.startDate || ''}
              onChange={(e) => handleInputChange('startDate', e.target.value)}
              placeholder="e.g. June 2020"
              className={styles.formInput}
            />
          </div>
          
          <div className={styles.formGroup}>
            <label htmlFor="endDate">End Date</label>
            <input
              type="text"
              id="endDate"
              value={experiences[currentIndex]?.endDate || ''}
              onChange={(e) => handleInputChange('endDate', e.target.value)}
              placeholder="e.g. Present"
              className={styles.formInput}
            />
          </div>
        </div>
        
        {/* Required Fields Warning */}
        {showRequiredFieldsWarning && (
          <div className={`${styles.completionHint} ${styles.warningHint}`}>
            <span className={styles.hintIcon}>⚠️</span>
            <span className={styles.hintText}>
              <strong>Please complete the required fields.</strong> Job Title and Company Name are needed to generate a relevant job description.
            </span>
          </div>
        )}
        
        {/* Improve visibility of this critical field */}
        <div className={styles.formGroup} style={{ marginBottom: '15px' }}>
          <label htmlFor="description" style={{ fontSize: '16px', marginBottom: '8px', display: 'flex', alignItems: 'center' }}>
            <span>Responsibilities</span>
            {jobContext && <span style={{ marginLeft: '5px', fontSize: '12px', color: '#1c7ed6', fontWeight: 'normal' }}>(Start each item on a new line)</span>}
          </label>

                  {/* Quick Tips */}
        <div style={{ 
          marginBottom: '20px', 
          padding: '15px',
          border: '1px solid #e9ecef',
          borderRadius: '8px',
          backgroundColor: '#f1f8ff'
        }}>
          <h4 style={{ fontSize: '14px', marginBottom: '10px', color: '#1c7ed6' }}>
            Quick Tips
          </h4>
          <ul style={{ paddingLeft: '20px', fontSize: '14px', color: '#495057' }}>
            <li style={{ marginBottom: '5px' }}>Begin with strong action verbs (Led, Developed, Increased, etc.)</li>
            <li style={{ marginBottom: '5px' }}>Include metrics and specific results where possible</li>
            <li style={{ marginBottom: '5px' }}>Begin each item on a new line & keep them concise and impactful</li>
          </ul>
          <p style={{ fontSize: '14px', marginTop: '10px', color: '#495057' }}>
            Example: <br />
            <span style={{ fontStyle: 'italic' }}>Increased sales by 30% through implementation of new CRM system</span><br />
            <span style={{ fontStyle: 'italic' }}>Managed team of 8 developers, reducing project delivery time by 25%</span>
          </p>
        </div>

          <textarea
            id="description"
            value={experiences[currentIndex]?.description || ''}
            onChange={(e) => handleInputChange('description', e.target.value)}
            placeholder="Describe your key responsibilities and achievements in this role. Start each point on a new line."
            className={styles.formInput}
            style={{
              minHeight: '180px',
              lineHeight: '1.6',
              paddingTop: '12px',
              paddingBottom: '12px',
              backgroundImage: 'linear-gradient(transparent 15px, #f1f3f5 16px)',
              backgroundSize: '100% 32px',
              backgroundAttachment: 'local'
            }}
            rows={8}
          />
        </div>
        
        <button 
          className={`${styles.aiButton} ${isGenerating ? styles.generating : ''}`}
          onClick={generateDescription}
          disabled={isGenerating}
        >
          {getButtonText()}
        </button>
        
        <div className={styles.completionHint}>
          <span className={styles.hintIcon}>💡</span>
          <span className={styles.hintText}>
            <strong>Pro Tip:</strong> Fill in all fields (title, company, dates) to auto-generate a description once. For revisions or new descriptions, use the Generate button. Quantify achievements whenever possible (e.g., "Increased sales by 20%").
          </span>
        </div>
      </div>
    </div>
  );
};

export default Experience; 